// Memoria de instrucciones para testear el pipeline MIPS
// Cada línea contiene una instrucción en formato hexadecimal de 32 bits

// Secuencia original modificada para probar forwarding unit
20010005  // addi $1, $0, 5       # $1 = 5
2002000A  // addi $2, $0, 10      # $2 = 10 
20030064  // addi $3, $0, 100     # $3 = 100 (dirección memoria)
20040014  // addi $4, $0, 20      # $4 = 20
2005000F  // addi $5, $0, 15      # $5 = 15

// TEST 1: Forwarding desde MEM a EX (no de EX a EX que requeriría stall)
00221820  // add $3, $1, $2       # $3 = $1 + $2 = 15 (sobreescribe el valor anterior de $3)
00642020  // add $4, $3, $4       # $4 = $3 + $4 = 15 + 20 = 35 (forwarding desde MEM)

// TEST 2: Forwarding desde MEM a EX (MEM-EX)
20050005  // addi $5, $0, 5       # $5 = 5
00A63020  // add $6, $5, $6       # $6 = $5 + $6 = 5 + 0 = 5 (dependencia MEM-EX)

// TEST 3: Sin forwarding (usando valores originales, con NOPs)
00433824  // and $7, $2, $3       # $7 = $2 & $3 = 10 & 15 = 10
00244025  // or $8, $1, $4        # $8 = $1 | $4 = 5 | 35 = 39

// Store/Load hazard tests
AC830000  // sw $3, 0($4)         # Mem[35] = $3 = 15
AC840004  // sw $4, 4($4)         # Mem[39] = $4 = 35 (forwarding de $4)
8CA90000  // lw $9, 0($5)         # $9 = Mem[$5+0] = Mem[5] (no valor relevante)
8C6A0000  // lw $10, 0($3)        # $10 = Mem[$3+0] = Mem[15] (no valor relevante)
012A5020  // add $10, $9, $10     # $10 = $9 + $10 (forwarding desde MEM)

// Recuperar valor original de $3 para las pruebas siguientes
20030064  // addi $3, $0, 100     # $3 = 100 (restauramos dirección memoria)

// Almacenar y leer valores para usarlos más adelante
AC650000  // sw $5, 0($3)         # Mem[100] = $5 = 5
8C6B0000  // lw $11, 0($3)        # $11 = Mem[100] = 5
01666020  // add $12, $11, $6     # $12 = $11 + $6 = 5 + 5 = 10 (ahora con MEM-EX forwarding)
AC660004  // sw $6, 4($3)         # Mem[104] = $6 = 5
8C6B0004  // lw $11, 4($3)        # $11 = Mem[104] = 5
00A66826  // xor $13, $5, $6      # $13 = $5 ^ $6 = 5 ^ 5 = 0

// Instrucciones de salto para probar la predicción (y forwarding en branches)
20090001  // addi $9, $0, 1       # $9 = 1 (para comparar en salto)
200E0003  // addi $14, $0, 3      # $14 = 3 (valor inicial)
21CE0001  // addi $14, $14, 1     # $14 = $14 + 1 = 4 (forwarding desde MEM)
21CE0001  // addi $14, $14, 1     # $14 = $14 + 1 = 5 (forwarding desde MEM)
112A0003  // beq $9, $10, 3       # Saltar si $9 == $10 (no se tomará, $9=1, $10 tiene otro valor)
21CE0001  // addi $14, $14, 1     # $14 = $14 + 1 = 6 (se ejecutará porque beq no salta)
21CE0001  // addi $14, $14, 1     # $14 = $14 + 1 = 7 (se ejecutará porque beq no salta)

200F0005  // addi $15, $0, 5      # $15 = 5 (para comparar en salto)
21CF0001  // addi $15, $15, 1     # $15 = $15 + 1 = 6 (forwarding desde MEM)
11E80001  // beq $15, $8, 1       # Saltar si $15 == $8 (no se tomará porque $15=6, $8=39)
21CF0001  // addi $15, $15, 1     # $15 = $15 + 1 = 7 (se ejecuta porque beq no salta)
21CF0001  // addi $15, $15, 1     # $15 = $15 + 1 = 8 (forwarding desde MEM)
200F0014  // addi $15, $0, 20     # $15 = 20 (escribir directamente 20)
20040014  // addi $4, $0, 20      # $4 = 20 (volver al valor original para las pruebas de salto)
11E40003  // beq $15, $4, 3       # Saltar si $15 == $4 (se tomará porque $15=20, $4=20)
21CF0001  // addi $15, $15, 1     # $15 = $15 + 1 = 21 (no se ejecutará si beq salta)
21CF0001  // addi $15, $15, 1     # $15 = $15 + 1 = 22 (no se ejecutará si beq salta)
21CF0001  // addi $15, $15, 1     # $15 = $15 + 1 = 22 (no se ejecutará si beq salta)

// Importante: Aguardar varios ciclos tras el salto para asegurar limpieza del pipeline
200E0005  // addi $14, $0, 5      # $14 = 5 (resetear el valor de $14 directamente)
21CE0001  // addi $14, $14, 1     # $14 = $14 + 1 = 6
21CE0001  // addi $14, $14, 1     # $14 = $14 + 1 = 7
FFFFFFFF  // halt 
